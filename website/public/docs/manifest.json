{
  "categories": [
    {
      "name": "Api",
      "slug": "api",
      "pages": [
        {
          "slug": "api/error",
          "title": "Error Handling",
          "summary": "Centralized error types with Result<T> alias and comprehensive error variants",
          "readWhen": [
            "You need to handle API errors, network failures, or validation issues",
            "You want to understand what can go wrong in the Alchemy crate",
            "You need to propagate errors using the ? operator"
          ],
          "content": "\r\n# Error Handling\r\n\r\nCentralized error types for the Alchemy crate. All errors are represented by the `Error` enum, and `Result<T>` is a type alias for `std::result::Result<T, Error>`.\r\n\r\n## Error Type\r\n\r\n```rust\r\n#[derive(Debug, thiserror::Error)]\r\npub enum Error {\r\n    #[error(\"No API key provided for provider: {0}\")]\r\n    NoApiKey(String),\r\n\r\n    #[error(\"HTTP request failed: {0}\")]\r\n    RequestError(#[from] reqwest::Error),\r\n\r\n    #[error(\"API returned error: {status_code} - {message}\")]\r\n    ApiError { status_code: u16, message: String },\r\n\r\n    #[error(\"Stream aborted\")]\r\n    Aborted,\r\n\r\n    #[error(\"Invalid response: {0}\")]\r\n    InvalidResponse(String),\r\n\r\n    #[error(\"Invalid header: {0}\")]\r\n    InvalidHeader(String),\r\n\r\n    #[error(\"Invalid JSON: {0}\")]\r\n    InvalidJson(#[from] serde_json::Error),\r\n\r\n    #[error(\"Model not found: provider={provider}, model_id={model_id}\")]\r\n    ModelNotFound { provider: String, model_id: String },\r\n\r\n    #[error(\"Unknown provider: {0}\")]\r\n    UnknownProvider(String),\r\n\r\n    #[error(\"Unknown API: {0}\")]\r\n    UnknownApi(String),\r\n\r\n    #[error(\"Tool validation failed: {0}\")]\r\n    ToolValidationFailed(String),\r\n\r\n    #[error(\"Tool not found: {0}\")]\r\n    ToolNotFound(String),\r\n\r\n    #[error(\"Context overflow: model context window exceeded\")]\r\n    ContextOverflow,\r\n}\r\n```\r\n\r\n## Result Type\r\n\r\n```rust\r\npub type Result<T> = std::result::Result<T, Error>;\r\n```\r\n\r\n## Error Variants\r\n\r\n| Variant | Description |\r\n|---------|-------------|\r\n| `NoApiKey` | No API key was found for the specified provider (check environment variables) |\r\n| `RequestError` | HTTP request failed (network issues, timeout, etc.) |\r\n| `ApiError` | Provider returned an error response with status code and message |\r\n| `Aborted` | Stream was aborted by the client |\r\n| `InvalidResponse` | Provider returned an unparseable response |\r\n| `InvalidHeader` | Invalid header value in response |\r\n| `InvalidJson` | JSON parsing failed |\r\n| `ModelNotFound` | Model not found in registry |\r\n| `UnknownProvider` | Provider not recognized |\r\n| `UnknownApi` | API type not recognized |\r\n| `ToolValidationFailed` | Tool call arguments failed schema validation |\r\n| `ToolNotFound` | Tool name not found in available tools |\r\n| `ContextOverflow` | Input exceeds model's context window |\r\n\r\n## Usage Example\r\n\r\n```rust\r\nuse alchemy::{Error, Result};\r\n\r\nfn make_request() -> Result<String> {\r\n    // Returns Ok(String) or Err(Error)\r\n    Ok(\"success\".to_string())\r\n}\r\n\r\nmatch make_request() {\r\n    Ok(response) => println!(\"Got: {}\", response),\r\n    Err(Error::NoApiKey(provider)) => {\r\n        eprintln!(\"Set {}_API_KEY environment variable\", provider);\r\n    }\r\n    Err(Error::ContextOverflow) => {\r\n        eprintln!(\"Conversation too long, consider summarizing\");\r\n    }\r\n    Err(e) => eprintln!(\"Error: {}\", e),\r\n}\r\n```\r\n\r\n## Propagation\r\n\r\nUse the `?` operator to propagate errors:\r\n\r\n```rust\r\nuse alchemy::{Error, Result};\r\n\r\nfn fetch_model(model_id: &str) -> Result<&'static AnyModel> {\r\n    let model = get_model(model_id)\r\n        .ok_or_else(|| Error::ModelNotFound {\r\n            provider: \"unknown\".to_string(),\r\n            model_id: model_id.to_string(),\r\n        })?;\r\n    Ok(model)\r\n}\r\n```\r\n",
          "category": "api",
          "order": 999
        },
        {
          "slug": "api/lib",
          "title": "Public API",
          "summary": "Public API surface with re-exports of all crate modules and entry points",
          "readWhen": [
            "You want to understand what's available in the alchemy crate",
            "You need to find the correct import for a type or function",
            "You're getting started with Alchemy and need an overview"
          ],
          "content": "\r\n# Public API\r\n\r\nThe `lib.rs` file defines the public API surface for the Alchemy crate. All publicly exported types and functions are re-exported here for convenience.\r\n\r\n## Module Structure\r\n\r\n```\r\nalchemy/\r\n  src/\r\n    lib.rs       # Public API re-exports\r\n    error.rs     # Error types\r\n    providers/   # Provider implementations\r\n    stream/      # Streaming API\r\n    transform.rs # Message transformation\r\n    types/       # Core type definitions\r\n    utils/       # Utility functions\r\n```\r\n\r\n## Public Exports\r\n\r\n### Error Types\r\n\r\n```rust\r\npub use error::{Error, Result};\r\n```\r\n\r\n### Provider Functions\r\n\r\n```rust\r\npub use providers::{\r\n    get_env_api_key,           // Get API key from environment\r\n    stream_openai_completions, // OpenAI completions streaming\r\n    OpenAICompletionsOptions,  // Options for OpenAI completions\r\n};\r\n```\r\n\r\n### Stream API\r\n\r\n```rust\r\npub use stream::{\r\n    complete,                      // Non-streaming completion\r\n    stream,                        // Streaming completion\r\n    AssistantMessageEventStream,   // Event stream type\r\n};\r\n```\r\n\r\n### Transform API\r\n\r\n```rust\r\npub use transform::{\r\n    transform_messages,        // Transform messages for target model\r\n    transform_messages_simple, // Transform without ID normalization\r\n    TargetModel,               // Target model information\r\n};\r\n```\r\n\r\n### Utilities\r\n\r\n```rust\r\npub use utils::{\r\n    is_context_overflow,         // Detect context overflow\r\n    parse_streaming_json,        // Parse incomplete JSON\r\n    parse_streaming_json_smart,  // Smart partial JSON parsing\r\n    sanitize_for_api,            // Sanitize strings for API\r\n    sanitize_surrogates,         // Remove UTF-16 surrogates\r\n    validate_tool_arguments,     // Validate tool call arguments\r\n    validate_tool_call,          // Validate tool against tools\r\n};\r\n```\r\n\r\n## Quick Start\r\n\r\n```rust\r\nuse alchemy::{\r\n    stream,\r\n    types::{Context, Message, UserContent},\r\n};\r\n\r\n#[tokio::main]\r\nasync fn main() -> alchemy::Result<()> {\r\n    let model = alchemy::get_model(\"claude-sonnet-4-20250514\")\r\n        .ok_or(\"Model not found\")?;\r\n\r\n    let context = Context {\r\n        messages: vec![Message::user(\"Hello, Claude!\")],\r\n        ..Default::default()\r\n    };\r\n\r\n    let mut stream = stream(&model, &context, &[])?;\r\n\r\n    while let Some(event) = stream.next().await {\r\n        println!(\"{:?}\", event);\r\n    }\r\n\r\n    Ok(())\r\n}\r\n```\r\n\r\n## Pattern: Streaming Completion\r\n\r\n```rust\r\nuse alchemy::{stream, types::*};\r\nuse futures::StreamExt;\r\n\r\nasync fn chat(messages: Vec<Message>) -> Result<AssistantMessage> {\r\n    let model = get_model(\"gpt-4o\")?;\r\n    let context = Context { messages, ..Default::default() };\r\n    let mut stream = stream(&model, &context, &[])?;\r\n\r\n    let mut response = String::new();\r\n    while let Some(event) = stream.next().await {\r\n        if let AssistantMessageEvent::Content(delta) = event {\r\n            response.push_str(&delta);\r\n            print!(\"{}\", delta);\r\n        }\r\n    }\r\n\r\n    Ok(AssistantMessage {\r\n        content: vec![Content::text(response)],\r\n        ..Default::default()\r\n    })\r\n}\r\n```\r\n\r\n## Pattern: Cross-Provider Transformation\r\n\r\n```rust\r\nuse alchemy::{transform_messages, types::*};\r\n\r\nfn switch_provider(messages: Vec<Message>) -> Vec<Message> {\r\n    let target = TargetModel {\r\n        api: Api::OpenAICompletions,\r\n        provider: Provider::Known(KnownProvider::OpenAI),\r\n        model_id: \"gpt-4o\".to_string(),\r\n    };\r\n\r\n    transform_messages_simple(&messages, &target)\r\n}\r\n```\r\n\r\n## Pattern: Tool Validation\r\n\r\n```rust\r\nuse alchemy::{validate_tool_call, types::*};\r\nuse serde_json::json;\r\n\r\nfn check_tool_call(tools: &[Tool], call: &ToolCall) -> Result<()> {\r\n    let validated_args = validate_tool_call(tools, call)?;\r\n    println!(\"Validated: {}\", validated_args);\r\n    Ok(())\r\n}\r\n```\r\n",
          "category": "api",
          "order": 999
        }
      ],
      "subcategories": []
    },
    {
      "name": "Utils",
      "slug": "utils",
      "pages": [
        {
          "slug": "utils/transform",
          "title": "Message Transformation",
          "summary": "Cross-provider message transformation for switching models/providers mid-conversation",
          "readWhen": [
            "You need to switch between different LLM providers during a conversation",
            "You want to understand how thinking blocks and tool calls are transformed",
            "You need to handle tool call ID normalization across providers"
          ],
          "content": "\r\n# Message Transformation\r\n\r\nCross-provider message transformation for conversation history compatibility. Handles thinking blocks, tool call IDs, orphaned tool calls, and error filtering.\r\n\r\n**Source:** `src/transform.rs` (~775 lines with tests)\r\n\r\n## Purpose\r\n\r\nWhen switching between models or providers during a conversation, message formats may not be directly compatible. The `transform_messages` function normalizes conversation history for the target model.\r\n\r\n## Key Transformations\r\n\r\n### 1. Thinking Block Handling\r\n\r\nThinking blocks (`<thinking>...</thinking>`) are handled differently based on the target:\r\n\r\n| Source | Target | Action |\r\n|--------|--------|--------|\r\n| Same model + signature | Same model + signature | Keep for replay |\r\n| Same model | Same model | Keep as-is |\r\n| Any | Different model | Convert to plain text |\r\n| Any | Any | Empty thinking is filtered out |\r\n\r\n### 2. Tool Call ID Normalization\r\n\r\nDifferent providers have different ID requirements. The optional `normalize_tool_call_id` function builds a mapping from original IDs to normalized IDs, then applies the mapping to tool results.\r\n\r\n### 3. Orphaned Tool Call Handling\r\n\r\nIf an assistant message contains tool calls but no results follow (e.g., user interrupted), synthetic error results are inserted. This satisfies API requirements that all tool calls must have corresponding results.\r\n\r\n### 4. Error/Abort Filtering\r\n\r\nAssistant messages with `stop_reason: Error` or `Aborted` are filtered out completely. These represent incomplete turns that should not be replayed.\r\n\r\n## API\r\n\r\n### TargetModel\r\n\r\nInformation about the target model for transformation.\r\n\r\n```rust\r\npub struct TargetModel {\r\n    pub api: Api,\r\n    pub provider: Provider,\r\n    pub model_id: String,\r\n}\r\n```\r\n\r\n### transform_messages\r\n\r\nFull transformation with optional tool call ID normalization.\r\n\r\n```rust\r\npub fn transform_messages<F>(\r\n    messages: &[Message],\r\n    target: &TargetModel,\r\n    normalize_tool_call_id: Option<F>,\r\n) -> Vec<Message>\r\nwhere\r\n    F: Fn(&str, &TargetModel, &AssistantMessage) -> String,\r\n```\r\n\r\n**Parameters:**\r\n- `messages`: Source conversation history\r\n- `target`: Target model information\r\n- `normalize_tool_call_id`: Optional function to normalize tool call IDs\r\n\r\n**Returns:** Transformed message vector\r\n\r\n### transform_messages_simple\r\n\r\nConvenience wrapper when no ID normalization is needed.\r\n\r\n```rust\r\npub fn transform_messages_simple(\r\n    messages: &[Message],\r\n    target: &TargetModel,\r\n) -> Vec<Message>\r\n```\r\n\r\n## Usage Examples\r\n\r\n### Basic Transformation (Same Provider)\r\n\r\n```rust\r\nuse alchemy::transform::{transform_messages_simple, TargetModel};\r\nuse alchemy::types::{Api, Provider, KnownProvider};\r\n\r\nlet target = TargetModel {\r\n    api: Api::AnthropicMessages,\r\n    provider: Provider::Known(KnownProvider::Anthropic),\r\n    model_id: \"claude-sonnet-4-20250514\".to_string(),\r\n};\r\n\r\nlet transformed = transform_messages_simple(&messages, &target);\r\n```\r\n\r\n### Cross-Provider with ID Normalization\r\n\r\n```rust\r\nuse alchemy::transform::{transform_messages, TargetModel};\r\nuse alchemy::types::{Api, Provider, KnownProvider};\r\n\r\nlet target = TargetModel {\r\n    api: Api::OpenAICompletions,\r\n    provider: Provider::Known(KnownProvider::OpenAI),\r\n    model_id: \"gpt-4o\".to_string(),\r\n};\r\n\r\n// Normalize Anthropic-style IDs to OpenAI format\r\nlet normalize = |id: &str, _target: &TargetModel, _msg: &AssistantMessage| -> String {\r\n    format!(\"call_{}\", id.replace('-', \"_\"))\r\n};\r\n\r\nlet transformed = transform_messages(&messages, &target, Some(normalize));\r\n```\r\n\r\n## Test Coverage\r\n\r\nThe module includes 15 comprehensive tests covering:\r\n\r\n- User message passthrough\r\n- Error message filtering\r\n- Aborted message filtering\r\n- Thinking block behavior (same/different model, with/without signature)\r\n- Empty thinking filtering\r\n- Text signature stripping\r\n- Tool call ID normalization\r\n- Orphaned tool call synthetic results\r\n- Multiple tool calls with partial results\r\n- Image content passthrough\r\n\r\nRun tests with:\r\n\r\n```bash\r\ncargo test --package alchemy --lib transform\r\n```\r\n\r\n## Implementation Notes\r\n\r\n### Two-Pass Algorithm\r\n\r\n1. **First pass:** Transform each message, build tool call ID mapping\r\n2. **Second pass:** Insert synthetic tool results for orphaned calls\r\n\r\n### State Tracking\r\n\r\nDuring transformation, the algorithm tracks:\r\n- `tool_call_id_map`: Maps original IDs to normalized IDs\r\n- `pending_tool_calls`: Tool calls waiting for results\r\n- `existing_result_ids`: Tool result IDs already seen\r\n\r\n### Signature Stripping\r\n\r\nSignatures (`text_signature`, `thinking_signature`, `thought_signature`) are stripped when transforming to a different model. They are only preserved for exact same-model replay.\r\n\r\n## See Also\r\n\r\n- [`types::Message`](../types/message.md) - Message types\r\n- [`types::Content`](../types/content.md) - Content block types\r\n- [`types::StopReason`](../types/stop_reason.md) - Stop reason enumeration\r\n- Phase 5 plan: `memory-bank/plan/phase-5-cross-provider-features.md`\r\n",
          "category": "utils",
          "order": 999
        }
      ],
      "subcategories": []
    }
  ],
  "pages": {
    "api/error": {
      "slug": "api/error",
      "title": "Error Handling",
      "summary": "Centralized error types with Result<T> alias and comprehensive error variants",
      "readWhen": [
        "You need to handle API errors, network failures, or validation issues",
        "You want to understand what can go wrong in the Alchemy crate",
        "You need to propagate errors using the ? operator"
      ],
      "content": "\r\n# Error Handling\r\n\r\nCentralized error types for the Alchemy crate. All errors are represented by the `Error` enum, and `Result<T>` is a type alias for `std::result::Result<T, Error>`.\r\n\r\n## Error Type\r\n\r\n```rust\r\n#[derive(Debug, thiserror::Error)]\r\npub enum Error {\r\n    #[error(\"No API key provided for provider: {0}\")]\r\n    NoApiKey(String),\r\n\r\n    #[error(\"HTTP request failed: {0}\")]\r\n    RequestError(#[from] reqwest::Error),\r\n\r\n    #[error(\"API returned error: {status_code} - {message}\")]\r\n    ApiError { status_code: u16, message: String },\r\n\r\n    #[error(\"Stream aborted\")]\r\n    Aborted,\r\n\r\n    #[error(\"Invalid response: {0}\")]\r\n    InvalidResponse(String),\r\n\r\n    #[error(\"Invalid header: {0}\")]\r\n    InvalidHeader(String),\r\n\r\n    #[error(\"Invalid JSON: {0}\")]\r\n    InvalidJson(#[from] serde_json::Error),\r\n\r\n    #[error(\"Model not found: provider={provider}, model_id={model_id}\")]\r\n    ModelNotFound { provider: String, model_id: String },\r\n\r\n    #[error(\"Unknown provider: {0}\")]\r\n    UnknownProvider(String),\r\n\r\n    #[error(\"Unknown API: {0}\")]\r\n    UnknownApi(String),\r\n\r\n    #[error(\"Tool validation failed: {0}\")]\r\n    ToolValidationFailed(String),\r\n\r\n    #[error(\"Tool not found: {0}\")]\r\n    ToolNotFound(String),\r\n\r\n    #[error(\"Context overflow: model context window exceeded\")]\r\n    ContextOverflow,\r\n}\r\n```\r\n\r\n## Result Type\r\n\r\n```rust\r\npub type Result<T> = std::result::Result<T, Error>;\r\n```\r\n\r\n## Error Variants\r\n\r\n| Variant | Description |\r\n|---------|-------------|\r\n| `NoApiKey` | No API key was found for the specified provider (check environment variables) |\r\n| `RequestError` | HTTP request failed (network issues, timeout, etc.) |\r\n| `ApiError` | Provider returned an error response with status code and message |\r\n| `Aborted` | Stream was aborted by the client |\r\n| `InvalidResponse` | Provider returned an unparseable response |\r\n| `InvalidHeader` | Invalid header value in response |\r\n| `InvalidJson` | JSON parsing failed |\r\n| `ModelNotFound` | Model not found in registry |\r\n| `UnknownProvider` | Provider not recognized |\r\n| `UnknownApi` | API type not recognized |\r\n| `ToolValidationFailed` | Tool call arguments failed schema validation |\r\n| `ToolNotFound` | Tool name not found in available tools |\r\n| `ContextOverflow` | Input exceeds model's context window |\r\n\r\n## Usage Example\r\n\r\n```rust\r\nuse alchemy::{Error, Result};\r\n\r\nfn make_request() -> Result<String> {\r\n    // Returns Ok(String) or Err(Error)\r\n    Ok(\"success\".to_string())\r\n}\r\n\r\nmatch make_request() {\r\n    Ok(response) => println!(\"Got: {}\", response),\r\n    Err(Error::NoApiKey(provider)) => {\r\n        eprintln!(\"Set {}_API_KEY environment variable\", provider);\r\n    }\r\n    Err(Error::ContextOverflow) => {\r\n        eprintln!(\"Conversation too long, consider summarizing\");\r\n    }\r\n    Err(e) => eprintln!(\"Error: {}\", e),\r\n}\r\n```\r\n\r\n## Propagation\r\n\r\nUse the `?` operator to propagate errors:\r\n\r\n```rust\r\nuse alchemy::{Error, Result};\r\n\r\nfn fetch_model(model_id: &str) -> Result<&'static AnyModel> {\r\n    let model = get_model(model_id)\r\n        .ok_or_else(|| Error::ModelNotFound {\r\n            provider: \"unknown\".to_string(),\r\n            model_id: model_id.to_string(),\r\n        })?;\r\n    Ok(model)\r\n}\r\n```\r\n",
      "category": "api",
      "order": 999
    },
    "api/lib": {
      "slug": "api/lib",
      "title": "Public API",
      "summary": "Public API surface with re-exports of all crate modules and entry points",
      "readWhen": [
        "You want to understand what's available in the alchemy crate",
        "You need to find the correct import for a type or function",
        "You're getting started with Alchemy and need an overview"
      ],
      "content": "\r\n# Public API\r\n\r\nThe `lib.rs` file defines the public API surface for the Alchemy crate. All publicly exported types and functions are re-exported here for convenience.\r\n\r\n## Module Structure\r\n\r\n```\r\nalchemy/\r\n  src/\r\n    lib.rs       # Public API re-exports\r\n    error.rs     # Error types\r\n    providers/   # Provider implementations\r\n    stream/      # Streaming API\r\n    transform.rs # Message transformation\r\n    types/       # Core type definitions\r\n    utils/       # Utility functions\r\n```\r\n\r\n## Public Exports\r\n\r\n### Error Types\r\n\r\n```rust\r\npub use error::{Error, Result};\r\n```\r\n\r\n### Provider Functions\r\n\r\n```rust\r\npub use providers::{\r\n    get_env_api_key,           // Get API key from environment\r\n    stream_openai_completions, // OpenAI completions streaming\r\n    OpenAICompletionsOptions,  // Options for OpenAI completions\r\n};\r\n```\r\n\r\n### Stream API\r\n\r\n```rust\r\npub use stream::{\r\n    complete,                      // Non-streaming completion\r\n    stream,                        // Streaming completion\r\n    AssistantMessageEventStream,   // Event stream type\r\n};\r\n```\r\n\r\n### Transform API\r\n\r\n```rust\r\npub use transform::{\r\n    transform_messages,        // Transform messages for target model\r\n    transform_messages_simple, // Transform without ID normalization\r\n    TargetModel,               // Target model information\r\n};\r\n```\r\n\r\n### Utilities\r\n\r\n```rust\r\npub use utils::{\r\n    is_context_overflow,         // Detect context overflow\r\n    parse_streaming_json,        // Parse incomplete JSON\r\n    parse_streaming_json_smart,  // Smart partial JSON parsing\r\n    sanitize_for_api,            // Sanitize strings for API\r\n    sanitize_surrogates,         // Remove UTF-16 surrogates\r\n    validate_tool_arguments,     // Validate tool call arguments\r\n    validate_tool_call,          // Validate tool against tools\r\n};\r\n```\r\n\r\n## Quick Start\r\n\r\n```rust\r\nuse alchemy::{\r\n    stream,\r\n    types::{Context, Message, UserContent},\r\n};\r\n\r\n#[tokio::main]\r\nasync fn main() -> alchemy::Result<()> {\r\n    let model = alchemy::get_model(\"claude-sonnet-4-20250514\")\r\n        .ok_or(\"Model not found\")?;\r\n\r\n    let context = Context {\r\n        messages: vec![Message::user(\"Hello, Claude!\")],\r\n        ..Default::default()\r\n    };\r\n\r\n    let mut stream = stream(&model, &context, &[])?;\r\n\r\n    while let Some(event) = stream.next().await {\r\n        println!(\"{:?}\", event);\r\n    }\r\n\r\n    Ok(())\r\n}\r\n```\r\n\r\n## Pattern: Streaming Completion\r\n\r\n```rust\r\nuse alchemy::{stream, types::*};\r\nuse futures::StreamExt;\r\n\r\nasync fn chat(messages: Vec<Message>) -> Result<AssistantMessage> {\r\n    let model = get_model(\"gpt-4o\")?;\r\n    let context = Context { messages, ..Default::default() };\r\n    let mut stream = stream(&model, &context, &[])?;\r\n\r\n    let mut response = String::new();\r\n    while let Some(event) = stream.next().await {\r\n        if let AssistantMessageEvent::Content(delta) = event {\r\n            response.push_str(&delta);\r\n            print!(\"{}\", delta);\r\n        }\r\n    }\r\n\r\n    Ok(AssistantMessage {\r\n        content: vec![Content::text(response)],\r\n        ..Default::default()\r\n    })\r\n}\r\n```\r\n\r\n## Pattern: Cross-Provider Transformation\r\n\r\n```rust\r\nuse alchemy::{transform_messages, types::*};\r\n\r\nfn switch_provider(messages: Vec<Message>) -> Vec<Message> {\r\n    let target = TargetModel {\r\n        api: Api::OpenAICompletions,\r\n        provider: Provider::Known(KnownProvider::OpenAI),\r\n        model_id: \"gpt-4o\".to_string(),\r\n    };\r\n\r\n    transform_messages_simple(&messages, &target)\r\n}\r\n```\r\n\r\n## Pattern: Tool Validation\r\n\r\n```rust\r\nuse alchemy::{validate_tool_call, types::*};\r\nuse serde_json::json;\r\n\r\nfn check_tool_call(tools: &[Tool], call: &ToolCall) -> Result<()> {\r\n    let validated_args = validate_tool_call(tools, call)?;\r\n    println!(\"Validated: {}\", validated_args);\r\n    Ok(())\r\n}\r\n```\r\n",
      "category": "api",
      "order": 999
    },
    "utils/transform": {
      "slug": "utils/transform",
      "title": "Message Transformation",
      "summary": "Cross-provider message transformation for switching models/providers mid-conversation",
      "readWhen": [
        "You need to switch between different LLM providers during a conversation",
        "You want to understand how thinking blocks and tool calls are transformed",
        "You need to handle tool call ID normalization across providers"
      ],
      "content": "\r\n# Message Transformation\r\n\r\nCross-provider message transformation for conversation history compatibility. Handles thinking blocks, tool call IDs, orphaned tool calls, and error filtering.\r\n\r\n**Source:** `src/transform.rs` (~775 lines with tests)\r\n\r\n## Purpose\r\n\r\nWhen switching between models or providers during a conversation, message formats may not be directly compatible. The `transform_messages` function normalizes conversation history for the target model.\r\n\r\n## Key Transformations\r\n\r\n### 1. Thinking Block Handling\r\n\r\nThinking blocks (`<thinking>...</thinking>`) are handled differently based on the target:\r\n\r\n| Source | Target | Action |\r\n|--------|--------|--------|\r\n| Same model + signature | Same model + signature | Keep for replay |\r\n| Same model | Same model | Keep as-is |\r\n| Any | Different model | Convert to plain text |\r\n| Any | Any | Empty thinking is filtered out |\r\n\r\n### 2. Tool Call ID Normalization\r\n\r\nDifferent providers have different ID requirements. The optional `normalize_tool_call_id` function builds a mapping from original IDs to normalized IDs, then applies the mapping to tool results.\r\n\r\n### 3. Orphaned Tool Call Handling\r\n\r\nIf an assistant message contains tool calls but no results follow (e.g., user interrupted), synthetic error results are inserted. This satisfies API requirements that all tool calls must have corresponding results.\r\n\r\n### 4. Error/Abort Filtering\r\n\r\nAssistant messages with `stop_reason: Error` or `Aborted` are filtered out completely. These represent incomplete turns that should not be replayed.\r\n\r\n## API\r\n\r\n### TargetModel\r\n\r\nInformation about the target model for transformation.\r\n\r\n```rust\r\npub struct TargetModel {\r\n    pub api: Api,\r\n    pub provider: Provider,\r\n    pub model_id: String,\r\n}\r\n```\r\n\r\n### transform_messages\r\n\r\nFull transformation with optional tool call ID normalization.\r\n\r\n```rust\r\npub fn transform_messages<F>(\r\n    messages: &[Message],\r\n    target: &TargetModel,\r\n    normalize_tool_call_id: Option<F>,\r\n) -> Vec<Message>\r\nwhere\r\n    F: Fn(&str, &TargetModel, &AssistantMessage) -> String,\r\n```\r\n\r\n**Parameters:**\r\n- `messages`: Source conversation history\r\n- `target`: Target model information\r\n- `normalize_tool_call_id`: Optional function to normalize tool call IDs\r\n\r\n**Returns:** Transformed message vector\r\n\r\n### transform_messages_simple\r\n\r\nConvenience wrapper when no ID normalization is needed.\r\n\r\n```rust\r\npub fn transform_messages_simple(\r\n    messages: &[Message],\r\n    target: &TargetModel,\r\n) -> Vec<Message>\r\n```\r\n\r\n## Usage Examples\r\n\r\n### Basic Transformation (Same Provider)\r\n\r\n```rust\r\nuse alchemy::transform::{transform_messages_simple, TargetModel};\r\nuse alchemy::types::{Api, Provider, KnownProvider};\r\n\r\nlet target = TargetModel {\r\n    api: Api::AnthropicMessages,\r\n    provider: Provider::Known(KnownProvider::Anthropic),\r\n    model_id: \"claude-sonnet-4-20250514\".to_string(),\r\n};\r\n\r\nlet transformed = transform_messages_simple(&messages, &target);\r\n```\r\n\r\n### Cross-Provider with ID Normalization\r\n\r\n```rust\r\nuse alchemy::transform::{transform_messages, TargetModel};\r\nuse alchemy::types::{Api, Provider, KnownProvider};\r\n\r\nlet target = TargetModel {\r\n    api: Api::OpenAICompletions,\r\n    provider: Provider::Known(KnownProvider::OpenAI),\r\n    model_id: \"gpt-4o\".to_string(),\r\n};\r\n\r\n// Normalize Anthropic-style IDs to OpenAI format\r\nlet normalize = |id: &str, _target: &TargetModel, _msg: &AssistantMessage| -> String {\r\n    format!(\"call_{}\", id.replace('-', \"_\"))\r\n};\r\n\r\nlet transformed = transform_messages(&messages, &target, Some(normalize));\r\n```\r\n\r\n## Test Coverage\r\n\r\nThe module includes 15 comprehensive tests covering:\r\n\r\n- User message passthrough\r\n- Error message filtering\r\n- Aborted message filtering\r\n- Thinking block behavior (same/different model, with/without signature)\r\n- Empty thinking filtering\r\n- Text signature stripping\r\n- Tool call ID normalization\r\n- Orphaned tool call synthetic results\r\n- Multiple tool calls with partial results\r\n- Image content passthrough\r\n\r\nRun tests with:\r\n\r\n```bash\r\ncargo test --package alchemy --lib transform\r\n```\r\n\r\n## Implementation Notes\r\n\r\n### Two-Pass Algorithm\r\n\r\n1. **First pass:** Transform each message, build tool call ID mapping\r\n2. **Second pass:** Insert synthetic tool results for orphaned calls\r\n\r\n### State Tracking\r\n\r\nDuring transformation, the algorithm tracks:\r\n- `tool_call_id_map`: Maps original IDs to normalized IDs\r\n- `pending_tool_calls`: Tool calls waiting for results\r\n- `existing_result_ids`: Tool result IDs already seen\r\n\r\n### Signature Stripping\r\n\r\nSignatures (`text_signature`, `thinking_signature`, `thought_signature`) are stripped when transforming to a different model. They are only preserved for exact same-model replay.\r\n\r\n## See Also\r\n\r\n- [`types::Message`](../types/message.md) - Message types\r\n- [`types::Content`](../types/content.md) - Content block types\r\n- [`types::StopReason`](../types/stop_reason.md) - Stop reason enumeration\r\n- Phase 5 plan: `memory-bank/plan/phase-5-cross-provider-features.md`\r\n",
      "category": "utils",
      "order": 999
    }
  }
}