{
  "slug": "api/lib",
  "title": "Public API",
  "summary": "Public API surface with re-exports of all crate modules and entry points",
  "readWhen": [
    "You want to understand what's available in the alchemy crate",
    "You need to find the correct import for a type or function",
    "You're getting started with Alchemy and need an overview"
  ],
  "content": "\r\n# Public API\r\n\r\nThe `lib.rs` file defines the public API surface for the Alchemy crate. All publicly exported types and functions are re-exported here for convenience.\r\n\r\n## Module Structure\r\n\r\n```\r\nalchemy/\r\n  src/\r\n    lib.rs       # Public API re-exports\r\n    error.rs     # Error types\r\n    providers/   # Provider implementations\r\n    stream/      # Streaming API\r\n    transform.rs # Message transformation\r\n    types/       # Core type definitions\r\n    utils/       # Utility functions\r\n```\r\n\r\n## Public Exports\r\n\r\n### Error Types\r\n\r\n```rust\r\npub use error::{Error, Result};\r\n```\r\n\r\n### Provider Functions\r\n\r\n```rust\r\npub use providers::{\r\n    get_env_api_key,           // Get API key from environment\r\n    stream_openai_completions, // OpenAI completions streaming\r\n    OpenAICompletionsOptions,  // Options for OpenAI completions\r\n};\r\n```\r\n\r\n### Stream API\r\n\r\n```rust\r\npub use stream::{\r\n    complete,                      // Non-streaming completion\r\n    stream,                        // Streaming completion\r\n    AssistantMessageEventStream,   // Event stream type\r\n};\r\n```\r\n\r\n### Transform API\r\n\r\n```rust\r\npub use transform::{\r\n    transform_messages,        // Transform messages for target model\r\n    transform_messages_simple, // Transform without ID normalization\r\n    TargetModel,               // Target model information\r\n};\r\n```\r\n\r\n### Utilities\r\n\r\n```rust\r\npub use utils::{\r\n    is_context_overflow,         // Detect context overflow\r\n    parse_streaming_json,        // Parse incomplete JSON\r\n    parse_streaming_json_smart,  // Smart partial JSON parsing\r\n    sanitize_for_api,            // Sanitize strings for API\r\n    sanitize_surrogates,         // Remove UTF-16 surrogates\r\n    validate_tool_arguments,     // Validate tool call arguments\r\n    validate_tool_call,          // Validate tool against tools\r\n};\r\n```\r\n\r\n## Quick Start\r\n\r\n```rust\r\nuse alchemy::{\r\n    stream,\r\n    types::{Context, Message, UserContent},\r\n};\r\n\r\n#[tokio::main]\r\nasync fn main() -> alchemy::Result<()> {\r\n    let model = alchemy::get_model(\"claude-sonnet-4-20250514\")\r\n        .ok_or(\"Model not found\")?;\r\n\r\n    let context = Context {\r\n        messages: vec![Message::user(\"Hello, Claude!\")],\r\n        ..Default::default()\r\n    };\r\n\r\n    let mut stream = stream(&model, &context, &[])?;\r\n\r\n    while let Some(event) = stream.next().await {\r\n        println!(\"{:?}\", event);\r\n    }\r\n\r\n    Ok(())\r\n}\r\n```\r\n\r\n## Pattern: Streaming Completion\r\n\r\n```rust\r\nuse alchemy::{stream, types::*};\r\nuse futures::StreamExt;\r\n\r\nasync fn chat(messages: Vec<Message>) -> Result<AssistantMessage> {\r\n    let model = get_model(\"gpt-4o\")?;\r\n    let context = Context { messages, ..Default::default() };\r\n    let mut stream = stream(&model, &context, &[])?;\r\n\r\n    let mut response = String::new();\r\n    while let Some(event) = stream.next().await {\r\n        if let AssistantMessageEvent::Content(delta) = event {\r\n            response.push_str(&delta);\r\n            print!(\"{}\", delta);\r\n        }\r\n    }\r\n\r\n    Ok(AssistantMessage {\r\n        content: vec![Content::text(response)],\r\n        ..Default::default()\r\n    })\r\n}\r\n```\r\n\r\n## Pattern: Cross-Provider Transformation\r\n\r\n```rust\r\nuse alchemy::{transform_messages, types::*};\r\n\r\nfn switch_provider(messages: Vec<Message>) -> Vec<Message> {\r\n    let target = TargetModel {\r\n        api: Api::OpenAICompletions,\r\n        provider: Provider::Known(KnownProvider::OpenAI),\r\n        model_id: \"gpt-4o\".to_string(),\r\n    };\r\n\r\n    transform_messages_simple(&messages, &target)\r\n}\r\n```\r\n\r\n## Pattern: Tool Validation\r\n\r\n```rust\r\nuse alchemy::{validate_tool_call, types::*};\r\nuse serde_json::json;\r\n\r\nfn check_tool_call(tools: &[Tool], call: &ToolCall) -> Result<()> {\r\n    let validated_args = validate_tool_call(tools, call)?;\r\n    println!(\"Validated: {}\", validated_args);\r\n    Ok(())\r\n}\r\n```\r\n",
  "category": "api",
  "order": 999
}